创建高性能索引
1.索引基础
    如果索引包含多个列mysql只能高校地使用索引的最左前缀列.
    1)索引的类型:
        B-Tree索引：
            适用于全键值，键值范围或键前缀查找。其中键前缀查询只使用于根据最左前缀的查找。
            注意：
                1.如果不是安装索引的最左列开始查找，则无法使用索引。
                2.不能跳过索引中的列
                3.如果查询中某个列的范围查询，则其右边所有列都无法使用索引优化查找。
            所以，索引列的顺序是非常重要的。在优化性能时，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。
        hash索引：
            基于hash表，只有精确匹配索引所有列的查询才有效。
            只适用特定场合。InnoDb有一个特殊功能“自适应哈希索引”，但某些索引被频繁使用，他会在内存中基于btree索引再创建一个哈希索引。

        还有其他索引，不作记录。主要还是btree索引。
    2）索引的优点：
        1.减少服务器扫描的数据量
        2.避免排序和临时表
        3.将随机IO变为顺序IO
    3）高性能索引策略：
        1.独立的列：
            指索引列不能时表达式的一部分，也不能时函数的参数。
            例如：select actor_id from actor where acotr_id +1 =5;
            最好始终将索引列单独的放在比较符号的一侧
        2.前缀索引和索引选择性：
            有时候需要索引很长的字符串，可以用模拟哈希索引。如果不够的话，可以使用前缀索引。详情见书。
        3.多列索引：
            常见错误：为每个列创建独立的索引。或者按照错误的顺序创建多列索引。
            虽然mysql5.0之后会自动优化独立索引，做索引合并。
            1.但出现服务器多个索引做相交操作时（多个and），通常意味着需要一个包含所有相关列的多列索引。而不是多个独立的单列索引。
            2.对多个索引做联合操作时（多个or），通常需要消费大量资源在算法的缓存，排序和合并操作上。
            3.可能会导致性能不如全表扫描
        4.合适的索引列顺序
            将选择性最高（数量最少）的列放到索引最前面。这个在某些场景有用，但通常不如避免随机IO和排序那么重要。
        5.聚簇索引：
            聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。innoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。
            InnoDB将通过主键聚集数据，也就是说，书中就是主键列。没有定义主键，InnoDB会隐式定义一个主键作为聚簇索引。
            优点：
                1.可以把相关数据保存在一起。
                2.数据访问更快。
                3.部分查询可以直接使用主键值
            缺点：
                1.提高IO密集应用的性能，但是数据放在内存中，就没那么重要了。
                2.插入速度依赖于插入顺序。
                3.更新代价高。
                4.导致“页分裂“使得占用更多空间
                5.可能导致全表扫描变慢。
                6.二级索引（非聚簇索引）比较大，因为二级索引的叶子节点包含了应用行的主键。
                7.二级索引访问要两次查找，而不是一次。因为二级索引保存"行指针"的实质,二级索引保存的时行的主键而不是物理位置.
                    意味着先找到聚簇索引之后才能找到具体行.

        6.覆盖索引






