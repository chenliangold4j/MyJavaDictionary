1.部署
    强行二进制部署，不二进制，不理解
        https://blog.csdn.net/fengfeng0328/article/details/85195695
2.准备
    5台 2c/4g/50g 使用同一内网
    centos7.6
    bind9
    自签名证书环境
    docker 以及harbor

3.调整yum源
 安装epel-release   (EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux.通过epel源可以安装大部分的软件包，)
    yum install epel-release



4.dns 服务初始化  (详情看dns相关课程)
    1.安装bind9 yum install bind -y
    2.配置bind9
        1. /etc/named.conf
            修改
            listen on prot 53{ 内网地址 }
            allow-query {any;}
            dnssec-enable:no;
            dnssec-validation no;
            添加：
            forwarders  { 内网网关 }

    3 named-checkconf
       没有报错则表明 配置named.conf 没有配置错误

    4.配置区域配置文件  (课程规划了两个域，主机域以及业务域)
    /etc/named.rfc1912.zones
    zone "host.com" IN{
        type master;
        file "host.com.zone";
        allow-update{172.26.216.148;};
    };

    zone "od.com" IN{
        type master;
        file "od.com.zone";
        allow-update{172.26.216.148;};
    }

    5 配置主机域数据文件：
       /var/named/host.com.zone

$ORIGIN  host.com.
$TTL 600        ;10 minutes
@ IN SOA dns.host.com. dnsadmin.host.com. (
        2020121215;Serial
        10800;Refresh
        900;Retry
        604800;Expire
        86400;Minimum
)
 NS dns.host.com.
$TTL 60; 1 minute
dns             A       172.26.216.148
HD-148          A       172.26.216.148
HD-145          A       172.26.216.145
HD-147          A       172.26.216.147
HD-149          A       172.26.216.149
HD-146          A       172.26.216.146



     /var/named/od.com.zone


    $ORIGIN  od.com.
    $TTL 600        ;10 minutes
    @ IN SOA dns.od.com. dnsadmin.od.com. (
            2020121215;Serial
            10800;Refresh
            900;Retry
            604800;Expire
            86400;Minimum
    )
     NS dns.od.com.
    $TTL 60; 1 minute
    dns             A       172.26.216.148

    named-checkconf 检查一下
    naemd-chekczone
    systemctl restart named

    yum install bind-utils
    dig -t A hd-149.host.com @172.26.216.148 +short  得到解析的地址

    6. 其他主机设置
    vim /etc/sysconfig/network-scripts/ifcfg-eth0
    systemctl restart network
      DNS1：172.26.216.148

      之后cat /etc/resolv.conf
        options timeout:2 attempts:3 rotate single-request-reopen
        ; generated by /usr/sbin/dhclient-script
        nameserver 172.26.216.148

      修改resolv.conf 添加
      search host.com
      (短域名搜索)


5.准备签发证书
    1.安装CFSSL

wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64
chmod +x cfssl_linux-amd64
wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64
chmod +x cfssljson_linux-amd64
wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64
chmod +x cfssl-certinfo_linux-amd64
mv cfssl_linux-amd64 /root/local/bin/cfssl
mv cfssl-certinfo_linux-amd64 /root/local/bin/cfssl-certinfo
mv cfssljson_linux-amd64 /root/local/bin/cfssljson
export PATH=/root/local/bin:$PATH

    2.需要一个根证书. 创建生产ca证书签名请求（csr)的json配置文件
    ca-csr.json 文件
    {
        "CN": "phantom5702",
        "hosts": [],
        "key": {
            "algo": "rsa",
            "size": 2048
        },
        "names": [{
            "C": "CN",
            "L": "beijing",
            "ST": "beijing",
            "O": "phantom5702",
            "OU": "ops"
        }],
        "ca": {
            "expiry": "175200h"
        }
    }
    cfssl gencert -initca ca-csr.json | cfssljson -bare ca
    [root@iZ8vb7b85wvb10l0kcmk03Z certs]# ls
    ca.csr  ca-csr.json  ca-key.pem  ca.pem

6 部署docker环境
     部署三台机器  c
    curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun
    /etc/docker/daemon.json
{
     "graph":"/var/lib/docker",
     "storage-driver":"overlay2",
     "insecure-registries": ["registry.access.redhat.com","quay.io","harbor.phantom5702.com"],
     "registry-mirrors":["https://tuj12vuh.mirror.aliyuncs.com"],
     "bip": "172.7.#{自己的ip最后尾数}.1/24",
     "exec-opts": ["native.cgroupdriver=systemd"],
     "live-restore":true
}

7.docker 私有仓库
    1.下载harbor
       git获取并解压
       编辑harbor.yml
       修改：hostname,修改为自己的工作域
            port 180
            harbor_admin_password  不改了
            log 地址
            data_volume

    2.依赖docker-compose
        yum install docker-compose -y

    3.调用install.sh   这里吧harbor.yml 的https相关配置注了，不然需要配置证书

    4.在此机器上安装nginx
        添加配置文件在nginx.conf下：  harbor.od.com.conf
server {
    listen       80;
    server_name  harbor.od.com;
    client_max_body_size 1000m;
    location / {
            proxy_pass http://127.0.0.1:180;
    }

}

server {
        listen       80;
        server_name  #{ip};
        client_max_body_size 1000m;
        location / {
                proxy_pass http://127.0.0.1:180;
        }
}

        systemctl start nginx
        systemctl enable nginx

    5.修改dns配置 /var/named/od.com.zone

        $ORIGIN  od.com.
        $TTL 600        ;10 minutes
        @ IN SOA dns.od.com. dnsadmin.od.com. (
                #注意序号要变动
                2020121216;Serial
                10800;Refresh
                900;Retry
                604800;Expire
                86400;Minimum
        )
         NS dns.od.com.
        $TTL 60; 1 minute
        dns             A       172.26.216.148
         #添加解析
        harbo           A       172.26.216.147
        systemctl restart named

    dig -t A harbor.od.com +short

    6.docker pull nginx:v1.7.9

        docker tag 7baf28ea91eb harbor.od.com/public/nginx:1.7.9 打一个tag
        docker push harbor.od.com/public/nginx:1.1.1  这里会失败

        docker login harbor.od.com
        之后可以push成功


8.安装master的etcd  (test2,test3,test4)
    1.给etcd签发证书，etcd之间通信需要证书
      创建基于根证书的config配置文件 ca-config.json
    {
        "signing": {
            "default": {
                "expiry": "175200h"
            },
            "profiles": {
                "server": {
                    "expiry": "175200h",
                    "usages": [
                        "signing",
                        "key encipherment",
                        "server auth"
                    ]
                },
                "client": {
                    "expiry": "175200h",
                    "usages": [
                        "signing",
                        "key encipherment",
                        "client auth"
                    ]
                },
                 "peer": {
                    "expiry": "175200h",
                    "usages": [
                        "signing",
                        "key encipherment",
                        "client auth"
                    ]
                }
            }
        }
    }

      创建etcd请求的证书文件
        {
        "CN": "k8s-etcd",
        "hosts": [
          "172.26.216.148",
          "172.26.216.145",
          "172.26.216.146",
          "172.26.216.147",
          "172.26.216.149"
        ],
        "key": {
          "algo": "rsa",
          "size": 2048
        },
        "names": [
          {
            "C": "CN",
            "ST": "BeiJing",
            "L": "BeiJing",
            "O": "od",
            "OU": "ops"
          }
        ]
        }

    cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=peer etcd-peer-csr.json

    cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=peer etcd-peer-csr.json | cfssljson -bare etcd-peer

    2. 创建etcd用户
        useradd -s /sbin/nologin -M etcd
    3.下载etcd github
        不建议超过3.3
    4.获取生成的证书文件
        ca.pem   etcd-peer-key.pem  etcd-peer.pem

    5.创建执行脚本etcd  参数根据情况改变
#!/bin/bash
./etcd --name etcd-server-145 \
       --data-dir /data/etcd/etcd-server \
       --listen-client-urls https://172.26.216.145:2379,https://127.0.0.1:2379 \
       --listen-peer-urls https://172.26.216.145:2380 \
       --quota-backend-bytes 8000000000 \
       --advertise-client-urls https://172.26.216.145:2380 \
       --initial-advertise-peer-urls https://172.26.216.145:2379,https://127.0.0.1:2379 \
       --initial-cluster etcd-server-145=https://172.26.216.145:2380,etcd-server-147=https://172.26.216.147:2380,etcd-server-149=https://172.26.216.149:2380 \
       --ca-file ./certs/ca.pem \
       --cert-file ./certs/etcd-peer.pem \
       --key-file ./certs/etcd-peer-key.pem \
       --client-cert-auth \
       --trusted-ca-file ./certs/ca.pem \
       --peer-ca-file ./certs/ca.pem \
       --peer-cert-file ./certs/etcd-peer.pem \
       --peer-key-file ./certs/etcd-peer-key.pem \
       --peer-client-cert-auth \
       --peer-trusted-ca-file ./certs/ca.pem

#!/bin/bash
./etcd --name etcd-server-149 \
       --data-dir /data/etcd/etcd-server \
       --listen-client-urls https://172.26.216.149:2379,https://127.0.0.1:2379 \
       --listen-peer-urls https://172.26.216.149:2380 \
       --quota-backend-bytes 8000000000 \
       --advertise-client-urls https://172.26.216.149:2380 \
       --initial-advertise-peer-urls https://172.26.216.149:2379,https://127.0.0.1:2379 \
       --initial-cluster etcd-server-145=https://172.26.216.145:2380,etcd-server-147=https://172.26.216.147:2380,etcd-server-149=https://172.26.216.149:2380 \
       --ca-file ./certs/ca.pem \
       --cert-file ./certs/etcd-peer.pem \
       --key-file ./certs/etcd-peer-key.pem \
       --client-cert-auth \
       --trusted-ca-file ./certs/ca.pem \
       --peer-ca-file ./certs/ca.pem \
       --peer-cert-file ./certs/etcd-peer.pem \
       --peer-key-file ./certs/etcd-peer-key.pem \
       --peer-client-cert-auth \
       --peer-trusted-ca-file ./certs/ca.pem



    6.改变etcd的所属人和组
       [root@iZ8vb7b85wvb10l0kcmk03Z opt]# chown -R etcd.etcd /opt/etcd-bin
       [root@iZ8vb7b85wvb10l0kcmk03Z opt]# chown -R etcd.etcd /data/etcd
       [root@iZ8vb7b85wvb10l0kcmk03Z opt]# chown -R etcd.etcd /data/logs/etcd-server/

    7 可选 （考虑用nohup 简单化）
      supervisor

      nohup sh start.sh >> test.log 2>&1 &

      netstat -luntp | grep etcd
      看到监听 2379 和 2380


9.kube-apiServer 集群
    计划放在 两个slave上
    在github上下载 解压

    如果etcd配置了证书，则这里需要配置证书

    详情见https://www.bilibili.com/video/BV1Gi4y1x7co?p=41

    使用脚本启动


10.配置反向代理两个apiServer,
    视频里面有用keepAlive做高可用，由于我这里用的阿里云,不做高可用，直接单机反代


stream{
    upstream kube-apiserver{
        server 172.26.216.159:6433      max_fails=3 fail_timeout=30s;
        server 172.26.216.160:6433      max_fails=3 fail_timeout=30s;
    }

    server{
        listen 7443;
        proxy_connect_timeout 2s;
        proxy_timeout 900s;
        proxy_pass kube-apiserver;
    }
}



11.controller-manager 和 scheduler
    执行脚本
    执行命令查看是否ok
    ./kubectl get cs
    NAME                 STATUS    MESSAGE             ERROR
    controller-manager   Healthy   ok
    scheduler            Healthy   ok
    etcd-1               Healthy   {"health":"true"}
    etcd-2               Healthy   {"health":"true"}
    etcd-0               Healthy   {"health":"true"}


12.kubelet

    证书

