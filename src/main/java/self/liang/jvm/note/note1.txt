1.jconsole 命令
      可以看到运行的堆内存，线程，类，cpu占用率等信息

2.jvisualvm命令  监控工具集大成者

3 jmap 命令行工具

4.问题：一般而言，对象首次创建会被放置在新生代的eden区，如果没有gc的介入就不会离开eden区，那么eden区的对象怎么进入老年代呢？

  主要有下面三种方式：大对象，长期存活的对象，动态对象年龄判定

  1：大对象直接进入老年代。比如很长的字符串，或者很大的数组等，参数-XX:PretenureSizeThreshold=3145728设置，超过这个参数设置的值就直接进入老年代

  2：长期存活的对象进入老年代。在堆中分配内存的对象，其内存布局的对象头中（Header）包含了 GC 分代年 龄标记信息。如果对象在 eden 区出生，那么它的 GC 分代年龄会初始值为 1，每熬过一次 Minor GC 而不被回收，这个值就会增  加 1 岁。当它的年龄到达一定的数值时，就会晋升到老年代中，可以通过参数-XX:MaxTenuringThreshold设置年龄阀值（默认是 15 岁）

  3：当 Survivor 空间中相同年龄所有对象的大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而不需要达到默认的分代年龄。

5.Minor GC触发条件：当Eden区满时，触发Minor GC。

  Full GC触发条件：

  （1）调用System.gc时，系统建议执行Full GC，但是不必然执行

  （2）老年代空间不足

  （3）方法区空间不足

  （4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存

  （5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
