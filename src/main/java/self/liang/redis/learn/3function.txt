1.发布订阅
    命令：
        1.订阅频道
            subscribe channel [channel ...] :订阅给定的一个或多个频道的信息
            psubscribe pattern [pattern ..] :订阅一个或多个符合模式的频道
        2.发布频道
            publish channell message:发送消息给频道
        3.退订频道：
            unsubscribe [channel [channel ...]] :退订给定频道
            punsubscribe  pattern [pattern ..]:退订指定模式的频道

         应用场景：
             有关发布订阅都可以。

2.redis 多数据库
    配置文件配置数据库数量
        database 16
    select 数据库的切换
    移动数据:
        move key databaseIndex
    数据库清空
        flushdb :清除当前数据库所有key
        flushall:清除整个redis的key

3.redis 事务
    既：一次执行多个命令。按顺序地串行化执行，执行中不会被其他命令插入，不许加塞
    redis不支持事务回滚
    常用命令：
        discard :取消事务
        exec : 执行所有事务块内的命令
        multi：标记事务开启
        unwatch:取消watch命令对所有key的监视
        watch [key ...] 监视多个key。如果再事务执行之前key被其他命令改动，那么事务将被打断
    一个事务从开始到执行会经历一下三个阶段：
        开始
        命令入队
        执行
        127.0.0.1:6379> set account:a 100
        OK
        127.0.0.1:6379> set account:b 20
        OK
        127.0.0.1:6379> multi
        OK
        127.0.0.1:6379> get account::a
        QUEUED
        127.0.0.1:6379> get account:a
        QUEUED
        127.0.0.1:6379> get account:b
        QUEUED
        127.0.0.1:6379> decrby account:a 50
        QUEUED
        127.0.0.1:6379> incrby account:b 50
        QUEUED
        127.0.0.1:6379> get account:a
        QUEUED
        127.0.0.1:6379> get account:b
        QUEUED
        127.0.0.1:6379> exec
        1) (nil)
        2) "100"
        3) "20"
        4) (integer) 50
        5) (integer) 70
        6) "50"
        7) "70"
    事务错误处理：
        1.如果执行的命令报错，只有报错的命令不会执行，其他命令会执行。不会回滚。
        2.队列中的某个命令出现了报告错误，执行时整个的所有队列都会被取消。（检测到错误命令。全部不执行）
        3.再multi之前watch了值。如果exec时发生变化，会取消执行
        WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。
        监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值）
    事务应用场景：
        一系列命令必须同时执行，例如秒杀

4.持久化
    1.RDB
        默认的持久化机制。快照方式，就是将内存种数据以快照的方式写入到二进制文件中，默认dump.rdb
        优点：保存数据快，还原数据块。适用于灾难备份
        缺点：小内存机器不适合。
        快照条件：
            1.正常关闭
            2.key满足一定条件。按照redis.conf中save的配置机制



        RDB 详解
        RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。

        从配置文件了解RDB
        打开 redis.conf 文件，找到 SNAPSHOTTING 对应内容
        1 RDB核心规则配置（重点）

        save <seconds> <changes>
        # save ""
        save 900 1
        save 300 10
        save 60 10000
        解说：save <指定时间间隔> <执行指定次数更新操作>，满足条件就将内存中的数据同步到硬盘中。官方出厂配置默认是 900秒内有1个更改，300秒内有10个更改以及60秒内有10000个更改，则将内存中的数据快照写入磁盘。
        若不想用RDB方案，可以把 save "" 的注释打开，下面三个注释。

        2 指定本地数据库文件名，一般采用默认的 dump.rdb

        dbfilename dump.rdb
        3 指定本地数据库存放目录，一般也用默认配置

        dir ./
        4 默认开启数据压缩

        rdbcompression yes
        解说：配置存储至本地数据库时是否压缩数据，默认为yes。Redis采用LZF压缩方式，但占用了一点CPU的时间。若关闭该选项，但会导致数据库文件变的巨大。建议开启。

        触发RDB快照
        1 在指定的时间间隔内，执行指定次数的写操作
        2 执行save（阻塞， 只管保存快照，其他的等待） 或者是bgsave （异步）命令
        3 执行flushall 命令，清空数据库所有数据，意义不大。
        4 执行shutdown 命令，保证服务器正常关闭且不丢失任何数据，意义...也不大。

        通过RDB文件恢复数据
        将dump.rdb 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可。在实际开发中，一般会考虑到物理机硬盘损坏情况，选择备份dump.rdb 。可以从下面的操作演示中可以体会到。

        RDB 的优缺点
        优点：
        1 适合大规模的数据恢复。
        2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。

        缺点：
        1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。
        2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。
        所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。


        实验：
            第一步：vim 修改持久化配置时间，120秒内修改5次则持久化一次。
            第二步：重启服务使配置生效。
            第三步：分别set 5个key，过两分钟后，在bin的当前目录下会自动生产一个dump.rdb文件。（set key6 是为了验证shutdown有触发RDB快照的作用）
            第四步：将当前的dump.rdb 备份一份（模拟线上工作）。
            第五步：执行FLUSHALL命令清空数据库数据（模拟数据丢失）。
            第六步：重启Redis服务，恢复数据.....咦？？？？( ′◔ ‸◔`)。数据是空的？？？？这是因为FLUSHALL也有触发RDB快照的功能。
            第七步：将备份的 dump_bk.rdb 替换 dump.rdb 然后重新Redis。

            注意点：SHUTDOWN 和 FLUSHALL 命令都会触发RDB快照，这是一个坑，请大家注意。


    2.AOF
        append-only file: redis将每一个写命令都追加到文件中，但redis重启时通过执行文件的命令再内存中重建整个数据库内容
        有三种方式：
            1.appendonly yes 启动持久话
            2.appendfsync always 收到命令就写入磁盘，最慢，但是保证持久化
            3.appendfsync everysec 每秒吸入一次
            4.appendfsync no 完全依赖os。
         缺陷：持久化文件过大。
         、


        AOF 详解
        AOF ：Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。

        从配置文件了解AOF
        打开 redis.conf 文件，找到 APPEND ONLY MODE 对应内容
        1 redis 默认关闭，开启需要手动把no改为yes

        appendonly yes
        2 指定本地数据库文件名，默认值为 appendonly.aof

        appendfilename "appendonly.aof"
        3 指定更新日志条件

        # appendfsync always
        appendfsync everysec
        # appendfsync no
        解说：
        always：同步持久化，每次发生数据变化会立刻写入到磁盘中。性能较差当数据完整性比较好（慢，安全）
        everysec：出厂默认推荐，每秒异步记录一次（默认值）
        no：不同步

        4 配置重写触发机制

        auto-aof-rewrite-percentage 100
        auto-aof-rewrite-min-size 64mb
        解说：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。一般都设置为3G，64M太小了。

        触发AOF快照
        根据配置文件触发，可以是每次执行触发，可以是每秒触发，可以不同步。

        根据AOF文件恢复数据
        正常情况下，将appendonly.aof 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可。但在实际开发中，可能因为某些原因导致appendonly.aof 文件格式异常，从而导致数据还原失败，可以通过命令redis-check-aof --fix appendonly.aof 进行修复 。从下面的操作演示中体会。

        AOF的重写机制
        前面也说到了，AOF的工作原理是将写操作追加到文件中，文件的冗余内容会越来越多。所以聪明的 Redis 新增了重写机制。当AOF文件的大小超过所设定的阈值时，Redis就会对AOF文件的内容压缩。

        重写的原理：Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件（你都那么大了，我还去读你？？？ o(ﾟДﾟ)っ傻啊！）。最后替换旧的aof文件。

        触发机制：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。这里的“一倍”和“64M” 可以通过配置文件修改。

        AOF 的优缺点
        优点：数据的完整性和一致性更高
        缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。


        实验：
            第一步：修改配置文件，开启AOF持久化配置。
            第二步：重启Redis服务，并进入Redis 自带的客户端中。
            第三步：保存值，然后模拟数据丢失，关闭Redis服务。
            第四步：重启服务，发现数据恢复了。（额外提一点：有教程显示FLUSHALL 命令会被写入AOF文件中，导致数据恢复失败。我安装的是redis-4.0.2没有遇到这个问题）。
            第五步：修改appendonly.aof，模拟文件异常情况。
            第六步：重启 Redis 服务失败。这同时也说明了，RDB和AOF可以同时存在，且优先加载AOF文件。
            第七步：校验appendonly.aof 文件。重启Redis 服务后正常。

            补充点：aof 的校验是通过 redis-check-aof 文件，那么rdb 的校验是不是可以通过 redis-check-rdb 文件呢？？？

5.缓存与数据库一致性。
    1.实时同步：
        这里可以用springboot-cache模块，修改的同时保存到缓存。

        缓存雪崩 缓存穿透 缓存击穿：
           1.缓存穿透：
                查询一个一定不存在的数据。导致一直往数据库查询，导致所有的查询直接到数据库。
                解决办法：查询不到，就缓存空结果。
           2.缓存雪崩：
               缓存雪崩，是指在某一个时间段，缓存集中过期失效。
               产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，
               假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，
               对于数据库而言，就会产生周期性的压力波峰

               解决办法：1.尽量让时间点均匀分布 2.限流
           3.缓存击穿
           是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，
           当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，
           就像在一个屏障上凿开了一个洞。

    2.异步队列
        采用消息中间件处理消息生产和消费。
    3.使用同步工具（程序）。
    4.使用UDF自定义函数方式。
        mysql的api编程，利用触发器进行缓存同步，但是UDF主要时C/C++语言实现。

5.并发：
    方法论上有两种：垂直扩展（scale up） 和 水平扩展（scale out）
    1.垂直扩展：提升单机能力
        1.增强硬件性能
        2.提升单机架构性能。如：缓存，异步请求。
       不足：单机性能有极限
    2.水平扩展：增加数量
        难点在于：如何再架构各层进行可水平扩展的设计。
