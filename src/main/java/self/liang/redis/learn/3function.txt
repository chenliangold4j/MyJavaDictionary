1.发布订阅
    命令：
        1.订阅频道
            subscribe channel [channel ...] :订阅给定的一个或多个频道的信息
            psubscribe pattern [pattern ..] :订阅一个或多个符合模式的频道
        2.发布频道
            publish channell message:发送消息给频道
        3.退订频道：
            unsubscribe [channel [channel ...]] :退订给定频道
            punsubscribe  pattern [pattern ..]:退订指定模式的频道

         应用场景：
             有关发布订阅都可以。

2.redis 多数据库
    配置文件配置数据库数量
        database 16
    select 数据库的切换
    移动数据:
        move key databaseIndex
    数据库清空
        flushdb :清除当前数据库所有key
        flushall:清除整个redis的key

3.redis 事务
    既：一次执行多个命令。按顺序地串行化执行，执行中不会被其他命令插入，不许加塞
    redis不支持事务回滚
    常用命令：
        discard :取消事务
        exec : 执行所有事务块内的命令
        multi：标记事务开启
        unwatch:取消watch命令对所有key的监视
        watch [key ...] 监视多个key。如果再事务执行之前key被其他命令改动，那么事务将被打断
    一个事务从开始到执行会经历一下三个阶段：
        开始
        命令入队
        执行
        127.0.0.1:6379> set account:a 100
        OK
        127.0.0.1:6379> set account:b 20
        OK
        127.0.0.1:6379> multi
        OK
        127.0.0.1:6379> get account::a
        QUEUED
        127.0.0.1:6379> get account:a
        QUEUED
        127.0.0.1:6379> get account:b
        QUEUED
        127.0.0.1:6379> decrby account:a 50
        QUEUED
        127.0.0.1:6379> incrby account:b 50
        QUEUED
        127.0.0.1:6379> get account:a
        QUEUED
        127.0.0.1:6379> get account:b
        QUEUED
        127.0.0.1:6379> exec
        1) (nil)
        2) "100"
        3) "20"
        4) (integer) 50
        5) (integer) 70
        6) "50"
        7) "70"
    事务错误处理：
        1.如果执行的命令报错，只有报错的命令不会执行，其他命令会执行。不会回滚。
        2.队列中的某个命令出现了报告错误，执行时整个的所有队列都会被取消。（检测到错误命令。全部不执行）
        3.再multi之前watch了值。如果exec时发生变化，会取消执行
    事务应用场景：
        一系列命令必须同时执行，例如秒杀

4.持久化
    1.RDB
        默认的持久化机制。快照方式，就是将内存种数据以快照的方式写入到二进制文件中，默认dump.rdb
        优点：保存数据快，还原数据块。适用于灾难备份
        缺点：小内存机器不适合。
        快照条件：
            1.正常关闭
            2.key满足一定条件。按照redis.conf中save的配置机制
    2.AOF
        append-only file: redis将每一个写命令都追加到文件中，但redis重启时通过执行文件的命令再内存中重建整个数据库内容
        有三种方式：
            1.appendonly yes 启动持久话
            2.appendfsync always 收到命令就写入磁盘，最慢，但是保证持久化
            3.appendfsync everysec 每秒吸入一次
            4.appendfsync no 完全依赖os。
         缺陷：持久化文件过大。

5.缓存与数据库一致性。
    1.实时同步：
        这里可以用springboot-cache模块，修改的同时保存到缓存。

        缓存雪崩 缓存穿透 缓存击穿：
           1.缓存穿透：
                查询一个一定不存在的数据。导致一直往数据库查询，导致所有的查询直接到数据库。
                解决办法：查询不到，就缓存空结果。
           2.缓存雪崩：
               缓存雪崩，是指在某一个时间段，缓存集中过期失效。
               产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，
               假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，
               对于数据库而言，就会产生周期性的压力波峰

               解决办法：1.尽量让时间点均匀分布 2.限流
           3.缓存击穿
           是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，
           当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，
           就像在一个屏障上凿开了一个洞。

    2.异步队列
        采用消息中间件处理消息生产和消费。
    3.使用同步工具（程序）。
    4.使用UDF自定义函数方式。
        mysql的api编程，利用触发器进行缓存同步，但是UDF主要时C/C++语言实现。

5.并发：
    方法论上有两种：垂直扩展（scale up） 和 水平扩展（scale out）
    1.垂直扩展：提升单机能力
        1.增强硬件性能
        2.提升单机架构性能。如：缓存，异步请求。
       不足：单机性能有极限
    2.水平扩展：增加数量
        难点在于：如何再架构各层进行可水平扩展的设计。
