记录一次看大佬修bug
    ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，
    也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，
    这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。

    与 BCEL 和 SERL 不同，ASM 提供了更为现代的编程模型。对于 ASM 来说，Java class 被描述为一棵树；使用 “Visitor” 模式遍历整个二进制结构；
    事件驱动的处理方式使得用户只需要关注于对其编程有意义的部分，而不必了解 Java 类文件格式的所有细节：ASM 框架提供了默认的 “response taker”处理这一切

    1.根据堆栈找到出错代码，由asm推测是字节码有问题

    2. 将byte数组输出至class文件。 这里学到debug下储存字节变量到文件。

    3. javap -v 或者 classpy 查看字节码  这里学到可以用idea的字节码插件查看 asm code outline 安装之后在view里面的show bytecode

    4.根据出错信息，到openjdk源码找输出地点。  但是没有其他信息。。build一个jdk。把出错位置的详细信息打印。

    5.找到ifeq -32745 几乎确定是越界

    6.找到生成自己码的asm的类，找到生成ifeq那行。查看方法发现已经有注释说明了越界的问题。并对比最新的asm类，发现已经处理。

    7.后面我已经理解不了了

